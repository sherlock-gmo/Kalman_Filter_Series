import numpy as np
from numpy.linalg import inv

class linear_kalman_filter():
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	def __init__(self):
		self.P_flag = True # Act. de covarianza: True=completa//False=simple
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	# Extrapolacion de estados
	def states_ext(self,F,B,W,Xnn,u):
		x1 = np.matmul(B,u)
		Xn1n = np.matmul(F,Xnn)+x1+W
		return Xn1n
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	# Extrapolacion de la covarianza
	def covariance_ext(self,F,Pnn,Q):
		p1 = np.matmul(F,Pnn)
		Pn1n = np.matmul(p1,np.transpose(F))+Q
		return Pn1n
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	# Actualizacion de la ganancia de Kalman
	def kalmanG_act(self,P,H,R):
		Ht = np.transpose(H)
		k1 = np.matmul(P,Ht)
		k2 = np.matmul(H,P)
		k3 = np.matmul(k2,Ht)+R
		k4 = inv(k3)
		Kn = np.matmul(k1,k4)
		return Kn
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	# Actualizacion de estados
	def states_act(self,Kn,H,X,z):
		x1 = np.matmul(H,X)
		x2 = np.matmul(Kn,z-x1) 
		Xnn = X+x2
		return Xnn
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	# Actualizacion de la covarianza
	def covarianze_act(self,P,H,Kn,R,N):
		# N = Numero de estados
		I = np.eye(N)
		p1 = I-np.matmul(Kn,H)
		p2 = np.matmul(p1,P)
		if (self.P_flag==False): Pnn = p2
		else:
			p3 = I-np.matmul(Kn,H)
			p4 = np.transpose(p3)
			p5 = np.matmul(p2,p4)
			p6 = np.matmul(Kn,R)
			p7 = np.matmul(p6,np.transpose(Kn))
			Pnn = p5+p7
		return Pnn
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	# Algoritmo del filtro de Kalman para un conjunto de mediciones 
	def alg_kalman_offline(self,X0,P0,F,B,W,u,H,R,Q,Z):
		Xk = []
		i = 0
		# Ajuste de tamanos
		N,_ = X0.shape 
		_,m = u.shape
		_,l = Z.shape
		for z in Z:
			zn = np.reshape(z,(l,1))
			un = np.reshape(u[i,:],(m,1))
			# Extrapolacion
			Xn1n = self.states_ext(F,B,W,X0,un)
			Pn1n = self.covariance_ext(F,P0,Q)
			# Actualizacion
			Knn = self.kalmanG_act(Pn1n,H,R)
			Xnn = self.states_act(Knn,H,Xn1n,zn)
			Pnn = self.covarianze_act(Pn1n,H,Knn,R,N)
			# Realimentacion del algoritmo
			X0 = Xnn
			P0 = Pnn
			i = i+1
			Xk.append(Xnn)
		return np.array(Xk)
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
# Ley de adaptacion
	def ladap(self,sign,gamma,e2,v):
		Dq = sign*gamma*e2*v
		return Dq
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	def runge_kutta04_1ord(self,q0,sign,gamma,e2,v,h):
		k1 = h * self.ladap(sign,gamma,e2,v)
		k2 = h * self.ladap(sign,gamma,e2,v)
		k3 = h * self.ladap(sign,gamma,e2,v)
		k4 = h * self.ladap(sign,gamma,e2,v)
		q = q0 + (k1 + 2*k2 + 2*k3 + k4) / 6
		return q[0]	
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------		
# Predictor en forma de estados
	def f1(self,Mh1,Mh2):
		return Mh2
	def f2(self,P,Mh1,Mh2):
		S,M,DM,sDM,a1,a2,b,c,d,alpha2,alpha1 = P
		DMh2 = (alpha2-a1)*DM+(alpha1-a2)*M-c*sDM+b*S+d-alpha2*Mh2-alpha1*Mh1
		return DMh2
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	def runge_kutta04_2ord(self,P, Mh20, Mh10, h):
		k1 = h * self.f1(Mh10, Mh20)
		l1 = h * self.f2(P, Mh10, Mh20)
		k2 = h * self.f1(Mh10 + k1/2, Mh20 + l1/2)
		l2 = h * self.f2(P, Mh10 + k1/2, Mh20 + l1/2)
		k3 = h * self.f1(Mh10 + k2/2, Mh20 + l2/2)
		l3 = h * self.f2(P, Mh10 + k2/2, Mh20 + l2/2)
		k4 = h * self.f1(Mh10 + k3, Mh20 + l3)
		l4 = h * self.f2(P, Mh10 + k3, Mh20 + l3)
		Mh1 = Mh10 + (k1 + 2*k2 + 2*k3 + k4) / 6
		Mh2 = Mh20 + (l1 + 2*l2 + 2*l3 + l4) / 6
		return Mh2, Mh1
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------
	def predictor(self,Par_q0,V,ALPHA,GAMMA,DM_hat0,M_hat0,h):
		# Predictor
		a10,a20,b0,c0,d0 = Par_q0
		alpha1, alpha2 = ALPHA
		S, M, DM = V
		if (abs(DM)>0.0): sDM = DM/abs(DM)
		else: sDM = 0.0
		P = [S,M,DM,sDM,a10,a20,b0,c0,d0,alpha2,alpha1]
		DM_hat, M_hat = self.runge_kutta04_2ord(P,DM_hat0,M_hat0,h)
		e1 = M_hat-M
		e2 = DM_hat-DM
		# Ley de adaptacion
		gamma1,gamma2,gamma3,gamma4,gamma5 = GAMMA
		a1 = self.runge_kutta04_1ord(a10,1.0,gamma1,e2,DM,h)
		a2 = self.runge_kutta04_1ord(a20,1.0,gamma2,e2,M,h)
		c = self.runge_kutta04_1ord(c0,1.0,gamma3,e2,sDM,h)
		b = self.runge_kutta04_1ord(b0,-1.0,gamma4,e2,S,h)
		d = self.runge_kutta04_1ord(d0,-1.0,gamma5,e2,1.0,h)
		return a1, a2, b, c, d, DM_hat, M_hat
		
		
		
		
		
		
		
		
		
		
		
		
		
